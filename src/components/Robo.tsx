/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useState } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { Mesh, SkinnedMesh } from 'three'
import * as THREE from 'three';
import { useFrame } from '@react-three/fiber';
interface ModelProps {
    scale?: number | [number, number, number];
    position?: [number, number, number];
    rotation?: [number, number, number];
}

const lightBlueEyeMaterial = new THREE.MeshPhysicalMaterial({
    color: "#2199F7", // Dodger blue base color
    emissive: "#1E90FF", // Emissive glow color
    emissiveIntensity: 1, // Adjust glow strength
    roughness: 0.2, // Smooth surface
    metalness: 0.5, // Slight metallic look
})

const lovePinkEyeMaterial = new THREE.MeshPhysicalMaterial({
    color: "#FF69B4",         // **Hot Pink base color**
    emissive: "#FF1493",      // **Deep Pink glow color**
    emissiveIntensity: 1,   // Increase glow strength
    roughness: 0.2,           // Smooth surface
    metalness: 0.5,           // Slight metallic look
});

const blinkingDelay = 4000;

const Robo = (props: ModelProps) => {
    const group = useRef<THREE.Group>()
    const { nodes, materials, animations } = useGLTF('/robo5.glb')
    const { actions } = useAnimations(animations, group)
    const [emotion, setEmotion] = useState('semi_happy');

    const [eyeMaterial, setEyeMaterial] = useState<THREE.MeshPhysicalMaterial>(lightBlueEyeMaterial)

    useEffect(() => {
        console.log("materials")
        console.log(materials)
        console.log("actions")
        console.log(actions)
        console.log("Morph Target Dictionaries")
        console.log((nodes.L_Eye as Mesh).morphTargetDictionary)
        console.log((nodes.R_Eye as Mesh).morphTargetDictionary)
        console.log("Morph Target Influences")
        console.log((nodes.L_Eye as Mesh).morphTargetInfluences)
        console.log((nodes.R_Eye as Mesh).morphTargetInfluences)

        const L_Eye = (nodes.L_Eye as Mesh)
        const R_Eye = (nodes.R_Eye as Mesh)
        if (L_Eye.morphTargetInfluences && L_Eye.morphTargetDictionary) {
            L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary["Close"]] = 0
            L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary["Love"]] = 1
            L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary["Happy"]] = 0
            L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary["semi_happy"]] = 0
            console.log("L_Eye morphTargetInfluences setting")
        }
        // if (actions) {
        //     Object.values(actions).forEach((action) => {
        //         if (action) {
        //             console.log(action)
        //             action.reset().fadeIn(0.5).play()
        //             return () => {
        //                 action.fadeOut(0.5)
        //             }
        //         }
        //     })
        // }

        const intervalId = setInterval(() => {
            setTimeout(() => {
                const prevEmotion = emotion
                setEmotion("Close")
                setTimeout(() => {
                    setEmotion(prevEmotion)
                }, 100)
            }, blinkingDelay - 400)

        }, blinkingDelay)
        return () => {
            clearInterval(intervalId)
        }
    }, [])

    const changeEmotion = (emotion: string) => {
        const L_Eye = (nodes.L_Eye as Mesh)
        const R_Eye = (nodes.R_Eye as Mesh)
        const emotions = ["Close", "Love", "Happy", "semi_happy"]
        emotions.forEach((e) => {
            if (e !== emotion) {
                const intervalId = setInterval(() => {
                    if (L_Eye.morphTargetInfluences && L_Eye.morphTargetDictionary) {
                        console.log('L_Eye.morphTargetDictionary[e]')
                        console.log(L_Eye.morphTargetDictionary)
                        console.log(L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary[e]])
                        const newValue = (L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary[e]] - 0.05)
                        L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary[e]] = newValue < 0 ? 0 : newValue > 1 ? 1 : newValue
                    }
                }, 50)
                setTimeout(() => {
                    clearInterval(intervalId);
                }, 1000)
                // if (L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary[e]] > 0) {
                //     L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary[e]] = 0
                // } else {
                //     intervalId = setInterval(() => {
                //         if (L_Eye.morphTargetInfluences && L_Eye.morphTargetDictionary) {
                //             console.log('L_Eye.morphTargetDictionary[e]')
                //             console.log(L_Eye.morphTargetDictionary)
                //             console.log(L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary[e]])
                //             const newValue = (L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary[e]] - 0.05)
                //             L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary[e]] = newValue < 0 ? 0 : newValue > 1 ? 1 : newValue
                //         }
                //     }, 50)
                //     setTimeout(() => {
                //         clearInterval(intervalId);
                //     }, 1000)
                // }
            } else {
                const intervalId = setInterval(() => {
                    if (L_Eye.morphTargetInfluences && L_Eye.morphTargetDictionary) {
                        console.log('L_Eye.morphTargetDictionary[e]')
                        console.log(L_Eye.morphTargetDictionary)
                        console.log(L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary[e]])
                        const newValue = (L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary[e]] + 0.05)
                        L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary[e]] = newValue < 0 ? 0 : newValue > 1 ? 1 : newValue
                    }
                }, 50)
                setTimeout(() => {
                    clearInterval(intervalId);
                }, 1000)
            }
        })
        // if (L_Eye.morphTargetInfluences && L_Eye.morphTargetDictionary) {
        //     L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary["Close"]] = 0
        //     L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary["Love"]] = 0
        //     L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary["Happy"]] = 0
        //     L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary["semi_happy"]] = 0
        //     L_Eye.morphTargetInfluences[L_Eye.morphTargetDictionary[emotion]] = 0.5

        //     console.log(`L_Eye morphTargetInfluences setting to ${emotion}`)
        // }
        // if (R_Eye.morphTargetInfluences && R_Eye.morphTargetDictionary) {
        //     R_Eye.morphTargetInfluences[R_Eye.morphTargetDictionary["Close"]] = 0
        //     R_Eye.morphTargetInfluences[R_Eye.morphTargetDictionary["Love"]] = 0
        //     R_Eye.morphTargetInfluences[R_Eye.morphTargetDictionary["Happy"]] = 0
        //     R_Eye.morphTargetInfluences[R_Eye.morphTargetDictionary["semi_happy"]] = 0
        //     R_Eye.morphTargetInfluences[R_Eye.morphTargetDictionary[emotion + ""]] = 1
        //     console.log(`R_Eye morphTargetInfluences setting to ${emotion}`)
        // }
    }

    useFrame(() => {
        const L_Eye = (nodes.L_Eye as Mesh)
        const R_Eye = (nodes.R_Eye as Mesh)
        const emotions = ["Close", "Love", "Happy", "semi_happy"]
        emotions.forEach((e) => {
            if (L_Eye.morphTargetInfluences && L_Eye.morphTargetDictionary) {
                const targetIndex = L_Eye.morphTargetDictionary[e];
                // console.log(e, L_Eye.morphTargetInfluences[targetIndex])
                if (emotion !== e) {
                    const newValue = L_Eye.morphTargetInfluences[targetIndex] - 0.5;
                    L_Eye.morphTargetInfluences[targetIndex] = newValue < 0 ? 0 : newValue >= 1 ? 1 : newValue
                }
            }
            if (R_Eye.morphTargetInfluences && R_Eye.morphTargetDictionary) {
                const targetIndex = R_Eye.morphTargetDictionary[e];
                // console.log(e, R_Eye.morphTargetInfluences[targetIndex])
                if (emotion !== e) {
                    const newValue = R_Eye.morphTargetInfluences[targetIndex] - 0.5;
                    R_Eye.morphTargetInfluences[targetIndex] = newValue < 0 ? 0 : newValue >= 1 ? 1 : newValue
                }
            }
        })
        if (L_Eye.morphTargetInfluences && L_Eye.morphTargetDictionary) {
            // Check if 'emotion' is a valid key in the dictionary
            if (L_Eye.morphTargetDictionary.hasOwnProperty(emotion)) {
                const targetIndex = L_Eye.morphTargetDictionary[emotion];
                // Set the target influence to 1
                L_Eye.morphTargetInfluences[targetIndex] = 1;
            } else {
                console.warn(`Emotion "${emotion}" not found in morphTargetDictionary.`);
            }
        } else {
            console.warn('No morphTargetInfluences or morphTargetDictionary on L_Eye.');
        }
        if (R_Eye.morphTargetInfluences && R_Eye.morphTargetDictionary) {
            // Check if 'emotion' is a valid key in the dictionary
            if (R_Eye.morphTargetDictionary.hasOwnProperty(emotion)) {
                const targetIndex = R_Eye.morphTargetDictionary[emotion];
                // Set the target influence to 1
                R_Eye.morphTargetInfluences[targetIndex] = 1;
            } else {
                console.warn(`Emotion "${emotion}" not found in morphTargetDictionary.`);
            }
        } else {
            console.warn('No morphTargetInfluences or morphTargetDictionary on L_Eye.');
        }

        // setDeltaPositionZ(Math.sin(Date.now() * 0.001) * 0.1);
        // setDeltaPositionY(Math.sin(Date.now() * 0.001) * 0.05);
        if (group.current) group.current.position.y = (props.position ? props.position[1] : 0) + Math.cos(Date.now() * 0.001) * 0.03;

        // console.log(Math.cos(Date.now() * 0.001))
        // const eyeDelta1 = Math.cos(Date.now() * 0.001)
        // const eyeDelta2 = eyeDelta1 >= 0.9 ? (1 - eyeDelta1) * 10 : 0
        // console.log(eyeDelta2)
        // if (L_Eye.morphTargetDictionary && L_Eye.morphTargetInfluences) {
        //     const targetIndex = L_Eye.morphTargetDictionary[emotion];
        //     L_Eye.morphTargetInfluences[targetIndex] = 1 - Math.abs(eyeDelta2);
        // }
        // if (R_Eye.morphTargetDictionary && R_Eye.morphTargetInfluences) {
        //     const targetIndex = R_Eye.morphTargetDictionary[emotion];
        //     R_Eye.morphTargetInfluences[targetIndex] = 1 - Math.abs(Math.cos(Date.now() * 0.001));
        // }
    })

    const hoveringBody = (isHovering: boolean) => {
        if (isHovering) {
            console.log("Hovering Body")
            // setEyeMaterial(lovePinkEyeMaterial)
            setEmotion("Love")
        } else {
            console.log("Not Hovering Body")
            // setEyeMaterial(lightBlueEyeMaterial)
            setEmotion("semi_happy")
        }
    }

    return (
        <group ref={group} {...props} dispose={null} onPointerOver={(e) => { hoveringBody(true) }} onPointerLeave={(e) => { hoveringBody(false) }}>
            <group name="Scene">
                <group name="Armature">
                    <skinnedMesh
                        name="Base"
                        geometry={(nodes.Base as Mesh).geometry}
                        // material={materials['Material.001']}
                        material={new THREE.MeshStandardMaterial({
                            color: "#000000", // Pure black
                            roughness: 0.05,  // Glossy for better reflection
                            metalness: 1,     // Metallic effect to reflect light
                            emissive: "#000000", // No self-emission
                            envMapIntensity: 3, // Boost reflections
                        })}
                        skeleton={(nodes.Base as SkinnedMesh).skeleton}>
                        <group name="Skin_8" position={[0, 2.016, 0.369]} />
                    </skinnedMesh>
                    <skinnedMesh
                        name="body"
                        geometry={(nodes.body as Mesh).geometry}
                        material={materials.body}
                        skeleton={(nodes.body as SkinnedMesh).skeleton}>
                        <group name="Skin" position={[0, 0.671, 0.023]} />
                    </skinnedMesh>
                    <skinnedMesh
                        name="Head"
                        geometry={(nodes.Head as Mesh).geometry}
                        material={materials.body}
                        skeleton={(nodes.Head as SkinnedMesh).skeleton}
                        rotation={[Math.PI, 0, 0]}
                    >
                        <group name="Skin_2" position={[1, 0.671, 0.023]} rotation={[-Math.PI / 2, 0, 0]} />
                    </skinnedMesh>
                    <skinnedMesh
                        name="l_antena"
                        geometry={(nodes.l_antena as Mesh).geometry}
                        material={materials.body}
                        skeleton={(nodes.l_antena as SkinnedMesh).skeleton}>
                        <group name="Skin_5" position={[0, 0.671, 0.023]} />
                    </skinnedMesh>
                    <skinnedMesh
                        name="L_braco"
                        geometry={(nodes.L_braco as Mesh).geometry}
                        material={materials.body}
                        skeleton={(nodes.L_braco as SkinnedMesh).skeleton}>
                        <group name="Skin_4" position={[0, 0.671, 0.023]} />
                    </skinnedMesh>
                    <skinnedMesh
                        name="L_Eye"
                        geometry={(nodes.L_Eye as Mesh).geometry}
                        // material={materials.eyes}
                        material={eyeMaterial}
                        skeleton={(nodes.L_Eye as SkinnedMesh).skeleton}
                        morphTargetDictionary={(nodes.L_Eye as SkinnedMesh).morphTargetDictionary}
                        morphTargetInfluences={(nodes.L_Eye as SkinnedMesh).morphTargetInfluences}>
                        <group name="Poses__L_Eye" rotation={[Math.PI / 2, 0, 0]} scale={0.001}>
                            <mesh
                                name="Close"
                                castShadow
                                receiveShadow
                                geometry={(nodes.Close as Mesh).geometry}
                                material={(nodes.Close as Mesh).material}
                                rotation={[-Math.PI / 2, 0, 0]}
                                scale={100}
                            />
                            <mesh
                                name="Happy"
                                castShadow
                                receiveShadow
                                geometry={(nodes.Happy as Mesh).geometry}
                                material={(nodes.Happy as Mesh).material}
                                rotation={[-Math.PI / 2, 0, 0]}
                                scale={100}
                            />
                            <mesh
                                name="Love"
                                castShadow
                                receiveShadow
                                geometry={(nodes.Love as Mesh).geometry}
                                material={(nodes.Love as Mesh).material}
                                rotation={[-Math.PI / 2, 0, 0]}
                                scale={100}
                            />
                            <mesh
                                name="semi_happy"
                                castShadow
                                receiveShadow
                                geometry={(nodes.semi_happy as Mesh).geometry}
                                // material={(nodes.semi_happy as Mesh).material}
                                rotation={[0, 0, 0]}
                                position={[1, 0, 0]}
                                scale={100}
                            />
                        </group>
                        <group name="Skin_10" />
                    </skinnedMesh>
                    <skinnedMesh
                        name="painel"
                        geometry={(nodes.painel as Mesh).geometry}
                        material={materials.body}
                        skeleton={(nodes.painel as SkinnedMesh).skeleton}>
                        <group name="Skin_7" position={[0, 0.671, 0.023]} />
                    </skinnedMesh>
                    <skinnedMesh
                        name="r_braco"
                        geometry={(nodes.r_braco as Mesh).geometry}
                        material={materials.body}
                        skeleton={(nodes.r_braco as SkinnedMesh).skeleton}>
                        <group name="Skin_3" position={[0, 0.671, 0.023]} />
                    </skinnedMesh>
                    <skinnedMesh
                        name="R_Eye"
                        geometry={(nodes.R_Eye as Mesh).geometry}
                        material={eyeMaterial}
                        skeleton={(nodes.R_Eye as SkinnedMesh).skeleton}
                        morphTargetDictionary={(nodes.R_Eye as SkinnedMesh).morphTargetDictionary}
                        morphTargetInfluences={(nodes.R_Eye as SkinnedMesh).morphTargetInfluences}>
                        <group name="Poses__R_Eye" rotation={[Math.PI / 2, 0, 0]} scale={0.001}>
                            <mesh
                                name="Close_2"
                                castShadow
                                receiveShadow
                                geometry={(nodes.Close_2 as Mesh).geometry}
                                material={(nodes.Close_2 as Mesh).material}
                                rotation={[-Math.PI / 2, 0, 0]}
                                scale={100}
                            />
                            <mesh
                                name="Happy_2"
                                castShadow
                                receiveShadow
                                geometry={(nodes.Happy_2 as Mesh).geometry}
                                material={(nodes.Happy_2 as Mesh).material}
                                rotation={[-Math.PI / 2, 0, 0]}
                                scale={100}
                            />
                            <mesh
                                name="Love_2"
                                castShadow
                                receiveShadow
                                geometry={(nodes.Love_2 as Mesh).geometry}
                                material={(nodes.Love_2 as Mesh).material}
                                // material={new THREE.MeshStandardMaterial({ color: "red" })}
                                rotation={[-Math.PI / 2, 0, 0]}
                                scale={100}
                            />
                            <mesh
                                name="semi_happy_2"
                                castShadow
                                receiveShadow
                                geometry={(nodes.semi_happy_2 as Mesh).geometry}
                                material={(nodes.semi_happy_2 as Mesh).material}
                                rotation={[-Math.PI / 2, 0, 0]}
                                scale={100}
                            />
                        </group>
                        <group name="Skin_11" />
                    </skinnedMesh>
                    <skinnedMesh
                        name="top_antena"
                        geometry={(nodes.top_antena as Mesh).geometry}
                        material={materials.body}
                        skeleton={(nodes.top_antena as SkinnedMesh).skeleton}>
                        <group name="Skin_6" position={[0, 0.671, 0.023]} />
                    </skinnedMesh>
                    <skinnedMesh
                        name="visor"
                        geometry={(nodes.visor as Mesh).geometry}
                        material={new THREE.MeshPhysicalMaterial({
                            color: "#ffffff",          // Light tint to glass
                            roughness: 0.5,           // Very smooth for reflections
                            transmission: 1,         // 90% transparent
                            thickness: 1,              // Gives depth to glass effect
                            reflectivity: 0.01,         // Strong reflections
                            clearcoat: 1,              // Enhances shine
                            clearcoatRoughness: 1,     // Glossy surface
                            opacity: 0.9,              // Partial transparency
                            side: THREE.DoubleSide,    // Render both sides
                            envMapIntensity: 3,        // Enhances reflections
                        })}
                        skeleton={(nodes.visor as SkinnedMesh).skeleton}>
                        <group name="Skin_9" position={[0, 0.671, 0.023]} />
                    </skinnedMesh>
                    <primitive object={nodes.Root} />
                </group>
            </group>
        </group>

    )
}

useGLTF.preload('/robo5.glb')

export default Robo